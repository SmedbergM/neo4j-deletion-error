package com.github.smedbergm.neo4jbug.neo4j

import java.io.File

import scala.collection.JavaConverters._
import com.github.smedbergm.neo4jbug.utils._
import com.typesafe.scalalogging.LazyLogging
import org.apache.tinkerpop.gremlin.neo4j.structure.Neo4jGraph
import gremlin.scala._
import org.apache.tinkerpop.gremlin.structure.Transaction

import scalaz.concurrent.Task

class ExampleDB4s(storageDirectory: File) extends ExampleDB with ScalazSupport with LazyLogging {
  import ExampleDB4s._
  import com.github.smedbergm.neo4jbug.Implicits._

  if (storageDirectory.exists && storageDirectory.isDirectory && storageDirectory.canWrite) {
    // OK
  } else if (storageDirectory.exists) {
    throw new IllegalArgumentException("Parameter storageDirectory must be a writable directory.")
  } else {
    assert(storageDirectory.mkdirs())
  }

  val graphDB: ScalaGraph = Neo4jGraph.open(storageDirectory.getAbsolutePath).asScala

  sys.addShutdownHook{
    graphDB.close()
  }

  def addFoo(foo: Foo): Task[Foo] = for {
    _ <- graphDB.V.hasLabel[Foo].has(idKey, foo.id).headOption().succeedIfEmpty
      .handleWith{ case NonemptyOption => Task.fail(BadRequestException(s"Foo #${foo.id} already exists."))}
    tx <- Task{graphDB.tx()}
    newVertex <- Task(graphDB + foo).handleWith(rollback(tx))
    _ = tx.commit()
  } yield newVertex.toCC[Foo]

  def getFoos(start: Int = 0, n: Int = Int.MaxValue): Task[List[Foo]] = Task {
    graphDB.V.hasLabel[Foo].map(_.toCC[Foo]).toStream.skip(start).iterator().asScala.take(n).toList
  }

  def removeFoo(fooID: Int): Task[Foo] = for {
    v <- graphDB.V.hasLabel[Foo].has(idKey, fooID).headOption().toTask
      .handleWith{ case EmptyOption => Task.fail(NotFoundException(s"Foo #${fooID} not found."))}
    _ = logger.debug(s"Located Foo #$fooID at vertex ${v}. Attempting to remove.")
    storedFoo <- Task(v.toCC[Foo])
    tx <- Task {graphDB.tx()}
    _ = logger.debug("Beginning transaction")
    _ <- v.out.drop.headOption().succeedIfEmpty.handleWith(rollback(tx))
    _ = logger.debug("Drop step completed.")
    _ <- Task.now(v.remove()).handleWith(rollback(tx))
    _ = logger.debug("Foo removal completed")
    _ = tx.commit()
  } yield storedFoo

  private def getOpenFooID: Task[Int] = {
    countFrom(0).find { x =>
      graphDB.V.hasLabel[Foo].has(idKey,x).headOption().isEmpty
    }.toTask.handleWith{ case EmptyOption => Task.fail(BadRequestException("Every possible ID is taken. How did you do that?"))}
  }

  def generateFooWithBars(n: Int): Task[Foo] = {
    getOpenFooID.map { fooID =>
      val tx = graphDB.tx()
      val fooV = graphDB + Foo(fooID, "Autogenerated Foo")
      tx.commit()
      fooV
    }.map { fooV =>
      val tx = graphDB.tx()
      (0 until n).foreach { barID =>
        val barV = graphDB + Bar(barID, s"Autogenerated barchild of Foo #${fooV.value2(idKey)}")
        fooV --- "owns" --> barV
      }
      tx.commit()
      fooV.toCC[Foo]
    }
  }

  def getBars(fooID: Int): Task[List[Bar]] = Task {
    graphDB.V
    .hasLabel[Foo]
    .has(idKey, fooID)
    .out
    .hasLabel[Bar]
    .map(_.toCC[Bar])
    .toList
  }

  def removeBar(fooID: Int, barID: Int): Task[Bar] = for {
    _ <- Task(logger.debug(s"Attempting to remove Bar #$barID from Foo #$fooID"))
    fooV <- graphDB.V.hasLabel[Foo].has(idKey, fooID).headOption.toTask
      .handleWith{ case EmptyOption =>
        val message = s"Foo #$fooID not found."
        logger.error(message)
        Task.fail(NotFoundException(message))}
    _ <- Task(logger.debug(s"Found Foo #$fooID at vertex $fooV"))
    barV <- fooV.out.hasLabel[Bar].has(idKey, barID).headOption.toTask
      .handleWith{ case EmptyOption =>
        val message = s"Bar #$barID not found."
        logger.error(message)
        Task.fail(NotFoundException(message))}
    _ <- Task(logger.debug(s"Found Bar #$barID at vertex $barV"))
    storedBar <- Task(barV.toCC[Bar])
    tx <- Task(graphDB.tx())
    _ <- Task(barV.remove()).handleWith(rollback(tx))
    _ = tx.commit()
  } yield storedBar

  def close(): Unit = graphDB.close()
}

object ExampleDB4s extends LazyLogging {
  val idKey = Key[Int]("id")
  val nameKey = Key[String]("name")

  def rollback[T](tx: Transaction): PartialFunction[Throwable, Task[T]] = {
    case exc =>
      logger.debug(s"Rolling back due to exception $exc")
      tx.rollback()
      Task.fail(exc).asInstanceOf[Task[T]]
  }

  private def countFrom(n: Int): Stream[Int] = if (n == Int.MaxValue) {
    Stream(n)
  } else {
    n #:: countFrom(n + 1)
  }
}

